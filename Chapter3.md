При реализации приложения часто приходится ссылаться из одного объекта на другой. Таким образом объект при выполнении своих функций может делегировать некоторые действия. Для реализации этого поведения необходимо установить связи между бинами в контексте Spring.

Это называется "внедрение зависимостей" (**Dependency Injection - DI**).

Есть три способа установки связей между бинами:
1. прямая ссылка на метод с аннотацией @Bean (который создает первый бин) из метода, который создает второй бин. Spring понимает, что вы ссылаетесь на бин, размещенный в контексте, и, если такой бин уже существует, не вызывает метод создания бина еще раз, а возвращает ссылку на тот, который уже есть;
```Java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot() {
        Parrot p = new Parrot();
        p.setName("Koko");
        return p;
    }

    @Bean
    public Person person() {
        Person p = new Person();
        p.setName("Ella");
        p.setParrot(parrot()); // Создание ссылки из бина person на бин parrot
    return p;
    }
}
```
2. определение параметра для метода с аннотацией @Bean. Когда Spring встречает метод с аннотацией @Bean и у этого метода есть параметр, то фреймворк ищет в контексте бин идентичного с параметром типа и поставляет в качестве значения параметра данный бин;
```Java
@Configuration
public class ProjectConfig {
    @Bean
    public Parrot parrot() {
        Parrot p = new Parrot();
        p.setName("Koko");
    return p;
    }

    @Bean
    public Person person(Parrot parrot) { // Spring внедряет бин parrot в этот параметр
        Person p = new Person();
        p.setName("Ella");
        p.setParrot(parrot);
    return p;
    }
}
```

3. использование аннотации @Autowired следующими способами:
- добавлением аннотации @Autowired к полю класса, чтобы Spring внедрил в это поле бин из контекста (нежелательный вариант);
```Java
@Component
public class Person {
    private String name = "Ella";
    @Autowired
    private Parrot parrot; // Добавив к полю аннотацию @Autowired, мы даем Spring команду внедрить в это поле соответствующее значение из контекста
    
    // геттеры и сеттеры
    
}
```
- добавлением аннотации @Autowired к конструктору, который Spring будет вызывать при создании бина. Тогда Spring внедрит другие бины из контекста в виде параметров конструктора. Такой способ чаще всего применяется в реальных приложениях;
```Java
@Component
public class Person {
    private String name = "Ella";
    private **final** Parrot parrot;

    @Autowired                      // Мы снабдили конструктор аннотацией @Autowired
    public Person(Parrot parrot) {
        this.parrot = parrot;
    }
    
    //геттеры и сеттеры
    
}
```
Зачастую, в промышленном варианте пометка @Autowired для конструктора не нужна, если класс состоит только из одного конструктора.
- добавлением аннотации @Autowired к сеттеру атрибута, в который Spring должен внедрить бин из контекста. Этот способ редко используется на практике.
```Java
@Component
public class Person {
    private String name = "Ella";
    private Parrot parrot;
    
    // другие геттеры и сеттеры
    
    @Autowired
    public void setParrot(Parrot parrot) {
        this.parrot = parrot;
    }
}
```

Всякий раз, когда Spring предоставляет значение или ссылку через атрибут класса, метод или параметр конструктора, это делается посредством DI — технологии, построенной по принципу IoC.

При создании двух бинов, зависящих друг от друга, возникает циклическая зависимость. Spring не может создать бины с циклической зависимостью, и при выполнении такого приложения возникает исключение. Работая с бинами, убедитесь, что между ними не возникает циклической зависимости.

Если в контексте Spring есть несколько бинов одного типа, фреймворк не может взять из них один для внедрения самостоятельно. Поэтому нужно указать Spring, какой из экземпляров нужно выбрать:
- с помощью аннотации @Primary, благодаря которой при внедрении зависимости один из бинов выбирается по умолчанию;
- присвоив бинам имена и внедряя их по именам с помощью аннотации @Qualifier.
